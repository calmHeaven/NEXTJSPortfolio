{
    "sourceFile": "node_modules/next/dist/server/lib/start-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1727918209051,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1727918214624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n         enumerable: true,\n         get: all[name]\n     });\n }\n-_export(exports, {}\n+_export(exports, \n     getRequestHandlers: function() {\n         return getRequestHandlers;\n     },\n     startServer: function() {\n"
                }
            ],
            "date": 1727918209051,
            "name": "Commit-0",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getRequestHandlers: null,\n    startServer: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {}\n    getRequestHandlers: function() {\n        return getRequestHandlers;\n    },\n    startServer: function() {\n        return startServer;\n    }\n});\nrequire(\"../next\");\nrequire(\"../require-hook\");\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _v8 = /*#__PURE__*/ _interop_require_default(require(\"v8\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _http = /*#__PURE__*/ _interop_require_default(require(\"http\"));\nconst _https = /*#__PURE__*/ _interop_require_default(require(\"https\"));\nconst _os = /*#__PURE__*/ _interop_require_default(require(\"os\"));\nconst _watchpack = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/watchpack\"));\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../../build/output/log\"));\nconst _debug = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/debug\"));\nconst _utils = require(\"./utils\");\nconst _formathostname = require(\"./format-hostname\");\nconst _routerserver = require(\"./router-server\");\nconst _constants = require(\"../../shared/lib/constants\");\nconst _appinfolog = require(\"./app-info-log\");\nconst _turbopackwarning = require(\"../../lib/turbopack-warning\");\nconst _trace = require(\"../../trace\");\nconst _ispostpone = require(\"./router-utils/is-postpone\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nif (performance.getEntriesByName(\"next-start\").length === 0) {\n    performance.mark(\"next-start\");\n}\nconst debug = (0, _debug.default)(\"next:start-server\");\nlet startServerSpan;\nasync function getRequestHandlers({ dir, port, isDev, server, hostname, minimalMode, isNodeDebugging, keepAliveTimeout, experimentalHttpsServer }) {\n    return (0, _routerserver.initialize)({\n        dir,\n        port,\n        hostname,\n        dev: isDev,\n        minimalMode,\n        server,\n        isNodeDebugging: isNodeDebugging || false,\n        keepAliveTimeout,\n        experimentalHttpsServer,\n        startServerSpan\n    });\n}\nasync function startServer(serverOptions) {\n    const { dir, isDev, hostname, minimalMode, allowRetry, keepAliveTimeout, selfSignedCertificate } = serverOptions;\n    let { port } = serverOptions;\n    process.title = `next-server (v${\"14.2.14\"})`;\n    let handlersReady = ()=>{};\n    let handlersError = ()=>{};\n    let handlersPromise = new Promise((resolve, reject)=>{\n        handlersReady = resolve;\n        handlersError = reject;\n    });\n    let requestHandler = async (req, res)=>{\n        if (handlersPromise) {\n            await handlersPromise;\n            return requestHandler(req, res);\n        }\n        throw new Error(\"Invariant request handler was not setup\");\n    };\n    let upgradeHandler = async (req, socket, head)=>{\n        if (handlersPromise) {\n            await handlersPromise;\n            return upgradeHandler(req, socket, head);\n        }\n        throw new Error(\"Invariant upgrade handler was not setup\");\n    };\n    // setup server listener as fast as possible\n    if (selfSignedCertificate && !isDev) {\n        throw new Error(\"Using a self signed certificate is only supported with `next dev`.\");\n    }\n    async function requestListener(req, res) {\n        try {\n            if (handlersPromise) {\n                await handlersPromise;\n                handlersPromise = undefined;\n            }\n            await requestHandler(req, res);\n        } catch (err) {\n            res.statusCode = 500;\n            res.end(\"Internal Server Error\");\n            _log.error(`Failed to handle request for ${req.url}`);\n            console.error(err);\n        } finally{\n            if (isDev) {\n                if (_v8.default.getHeapStatistics().used_heap_size > 0.8 * _v8.default.getHeapStatistics().heap_size_limit) {\n                    _log.warn(`Server is approaching the used memory threshold, restarting...`);\n                    (0, _trace.trace)(\"server-restart-close-to-memory-threshold\", undefined, {\n                        \"memory.heapSizeLimit\": String(_v8.default.getHeapStatistics().heap_size_limit),\n                        \"memory.heapUsed\": String(_v8.default.getHeapStatistics().used_heap_size)\n                    }).stop();\n                    await (0, _trace.flushAllTraces)();\n                    process.exit(_utils.RESTART_EXIT_CODE);\n                }\n            }\n        }\n    }\n    const server = selfSignedCertificate ? _https.default.createServer({\n        key: _fs.default.readFileSync(selfSignedCertificate.key),\n        cert: _fs.default.readFileSync(selfSignedCertificate.cert)\n    }, requestListener) : _http.default.createServer(requestListener);\n    if (keepAliveTimeout) {\n        server.keepAliveTimeout = keepAliveTimeout;\n    }\n    server.on(\"upgrade\", async (req, socket, head)=>{\n        try {\n            await upgradeHandler(req, socket, head);\n        } catch (err) {\n            socket.destroy();\n            _log.error(`Failed to handle request for ${req.url}`);\n            console.error(err);\n        }\n    });\n    let portRetryCount = 0;\n    server.on(\"error\", (err)=>{\n        if (allowRetry && port && isDev && err.code === \"EADDRINUSE\" && portRetryCount < 10) {\n            _log.warn(`Port ${port} is in use, trying ${port + 1} instead.`);\n            port += 1;\n            portRetryCount += 1;\n            server.listen(port, hostname);\n        } else {\n            _log.error(`Failed to start server`);\n            console.error(err);\n            process.exit(1);\n        }\n    });\n    const nodeDebugType = (0, _utils.checkNodeDebugType)();\n    await new Promise((resolve)=>{\n        server.on(\"listening\", async ()=>{\n            const addr = server.address();\n            const actualHostname = (0, _formathostname.formatHostname)(typeof addr === \"object\" ? (addr == null ? void 0 : addr.address) || hostname || \"localhost\" : addr);\n            const formattedHostname = !hostname || actualHostname === \"0.0.0.0\" ? \"localhost\" : actualHostname === \"[::]\" ? \"[::1]\" : (0, _formathostname.formatHostname)(hostname);\n            port = typeof addr === \"object\" ? (addr == null ? void 0 : addr.port) || port : port;\n            const networkUrl = hostname ? `http://${actualHostname}:${port}` : null;\n            const appUrl = `${selfSignedCertificate ? \"https\" : \"http\"}://${formattedHostname}:${port}`;\n            if (nodeDebugType) {\n                const debugPort = (0, _utils.getDebugPort)();\n                _log.info(`the --${nodeDebugType} option was detected, the Next.js router server should be inspected at port ${debugPort}.`);\n            }\n            // expose the main port to render workers\n            process.env.PORT = port + \"\";\n            process.env.__NEXT_PRIVATE_ORIGIN = appUrl;\n            // Only load env and config in dev to for logging purposes\n            let envInfo;\n            let expFeatureInfo;\n            if (isDev) {\n                const startServerInfo = await (0, _appinfolog.getStartServerInfo)(dir, isDev);\n                envInfo = startServerInfo.envInfo;\n                expFeatureInfo = startServerInfo.expFeatureInfo;\n            }\n            (0, _appinfolog.logStartInfo)({\n                networkUrl,\n                appUrl,\n                envInfo,\n                expFeatureInfo,\n                maxExperimentalFeatures: 3\n            });\n            _log.event(`Starting...`);\n            try {\n                const cleanup = ()=>{\n                    debug(\"start-server process cleanup\");\n                    server.close(()=>process.exit(0));\n                };\n                const exception = (err)=>{\n                    if ((0, _ispostpone.isPostpone)(err)) {\n                        // React postpones that are unhandled might end up logged here but they're\n                        // not really errors. They're just part of rendering.\n                        return;\n                    }\n                    // This is the render worker, we keep the process alive\n                    console.error(err);\n                };\n                // Make sure commands gracefully respect termination signals (e.g. from Docker)\n                // Allow the graceful termination to be manually configurable\n                if (!process.env.NEXT_MANUAL_SIG_HANDLE) {\n                    process.on(\"SIGINT\", cleanup);\n                    process.on(\"SIGTERM\", cleanup);\n                }\n                process.on(\"rejectionHandled\", ()=>{\n                // It is ok to await a Promise late in Next.js as it allows for better\n                // prefetching patterns to avoid waterfalls. We ignore loggining these.\n                // We should've already errored in anyway unhandledRejection.\n                });\n                process.on(\"uncaughtException\", exception);\n                process.on(\"unhandledRejection\", exception);\n                const initResult = await getRequestHandlers({\n                    dir,\n                    port,\n                    isDev,\n                    server,\n                    hostname,\n                    minimalMode,\n                    isNodeDebugging: Boolean(nodeDebugType),\n                    keepAliveTimeout,\n                    experimentalHttpsServer: !!selfSignedCertificate\n                });\n                requestHandler = initResult[0];\n                upgradeHandler = initResult[1];\n                const startServerProcessDuration = performance.mark(\"next-start-end\") && performance.measure(\"next-start-duration\", \"next-start\", \"next-start-end\").duration;\n                handlersReady();\n                const formatDurationText = startServerProcessDuration > 2000 ? `${Math.round(startServerProcessDuration / 100) / 10}s` : `${Math.round(startServerProcessDuration)}ms`;\n                _log.event(`Ready in ${formatDurationText}`);\n                if (process.env.TURBOPACK) {\n                    await (0, _turbopackwarning.validateTurboNextConfig)({\n                        dir: serverOptions.dir,\n                        isDev: true\n                    });\n                }\n            } catch (err) {\n                // fatal error if we can't setup\n                handlersError();\n                console.error(err);\n                process.exit(1);\n            }\n            resolve();\n        });\n        server.listen(port, hostname);\n    });\n    if (isDev) {\n        function watchConfigFiles(dirToWatch, onChange) {\n            const wp = new _watchpack.default();\n            wp.watch({\n                files: _constants.CONFIG_FILES.map((file)=>_path.default.join(dirToWatch, file))\n            });\n            wp.on(\"change\", onChange);\n        }\n        watchConfigFiles(dir, async (filename)=>{\n            if (process.env.__NEXT_DISABLE_MEMORY_WATCHER) {\n                _log.info(`Detected change, manual restart required due to '__NEXT_DISABLE_MEMORY_WATCHER' usage`);\n                return;\n            }\n            _log.warn(`Found a change in ${_path.default.basename(filename)}. Restarting the server to apply the changes...`);\n            process.exit(_utils.RESTART_EXIT_CODE);\n        });\n    }\n}\nif (process.env.NEXT_PRIVATE_WORKER && process.send) {\n    process.addListener(\"message\", async (msg)=>{\n        if (msg && typeof msg && msg.nextWorkerOptions && process.send) {\n            startServerSpan = (0, _trace.trace)(\"start-dev-server\", undefined, {\n                cpus: String(_os.default.cpus().length),\n                platform: _os.default.platform(),\n                \"memory.freeMem\": String(_os.default.freemem()),\n                \"memory.totalMem\": String(_os.default.totalmem()),\n                \"memory.heapSizeLimit\": String(_v8.default.getHeapStatistics().heap_size_limit)\n            });\n            await startServerSpan.traceAsyncFn(()=>startServer(msg.nextWorkerOptions));\n            const memoryUsage = process.memoryUsage();\n            startServerSpan.setAttribute(\"memory.rss\", String(memoryUsage.rss));\n            startServerSpan.setAttribute(\"memory.heapTotal\", String(memoryUsage.heapTotal));\n            startServerSpan.setAttribute(\"memory.heapUsed\", String(memoryUsage.heapUsed));\n            process.send({\n                nextServerReady: true\n            });\n        }\n    });\n    process.send({\n        nextWorkerReady: true\n    });\n}\n\n//# sourceMappingURL=start-server.js.map"
        }
    ]
}